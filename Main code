%% 初始化环境
clear all;
close all;
clc;

%% 定义常量
% 将常量放在一个结构体中，便于传递
global CONFIG
CONFIG.LANE_WIDTH = 3; % 车道宽度(m)
CONFIG.CAR_LENGTH = 4.5; % 汽车长度(m)
CONFIG.CAR_WIDTH = 2; % 汽车宽度(m)
CONFIG.BIKE_LENGTH = 2; % 自行车长度(m)
CONFIG.BIKE_WIDTH = 0.8; % 自行车宽度(m)
CONFIG.CAR_MAX_SPEED = 20 * 0.44704; % 汽车最大速度(英里/h转换为m/s)
CONFIG.BIKE_MAX_SPEED = 9 * 0.44704; % 自行车最大速度(英里/h转换为m/s)
CONFIG.CAR_MAX_ACCEL = 2.5; % 汽车最大加速度(m/s²)
CONFIG.BIKE_MAX_ACCEL = 1.5; % 自行车最大加速度(m/s²)
CONFIG.CAR_MAX_DECEL = 4.5; % 汽车最大减速度(m/s²)
CONFIG.BIKE_MAX_DECEL = 3.0; % 自行车最大减速度(m/s²)
CONFIG.SIM_TIME = 300; % 仿真总时长(s)
CONFIG.TIME_STEP = 0.1; % 仿真时间步长(s)
CONFIG.SIGNAL_CYCLE = 30; % 信号灯周期(s)
CONFIG.PED_PHASE_PROB = 0.2; % 行人通行相位触发概率
CONFIG.SAFE_DISTANCE_MIN = 2; % 最小安全距离(m)
CONFIG.HEADWAY_TIME = 1.5; % 车头时距(s)
CONFIG.CAR_TO_BIKE_RATIO = 5; % 汽车与自行车生成比例
CONFIG.SPAWN_RATE = 0.2; % 每秒新车辆生成概率

%% 读取数据
disp('读取节点和道路数据...');
[nodes, roads] = readTrafficData('model_updated_nodes_converted.xlsx');

%% 建立模型
disp('建立模型...');
% 建立拓扑结构模型（节点、道路、路口）
trafficModel = buildTopologyModel(nodes, roads);

% 初始化信号灯
trafficLights = initializeTrafficLights(trafficModel);

% 初始化交通参与者（汽车和自行车）
% 使用结构体数组初始化，确保字段存在
vehicles = struct('id', {}, 'type', {}, 'laneIdx', {}, 'x', {}, 'y', {}, ...
                  'direction', {}, 'speed', {}, 'acceleration', {}, 'distance', {}, ...
                  'nextNodeIdx', {}, 'status', {}, 'waitingTime', {}, 'stopCount', {}, ...
                  'totalTime', {}, 'lowSpeedTime', {}, 'length', {}, 'width', {}, ...
                  'maxSpeed', {}, 'maxAccel', {}, 'maxDecel', {});

%% 初始化统计数据
numRoads = numel(roads.id);  % 正确的道路数量
stats = struct();
stats.roadCapacity = zeros(numRoads, ceil(CONFIG.SIM_TIME/2));
stats.pedestrianPhaseTime = 0;
stats.carLowSpeedTime = 0;
stats.carTotalTime = 0;
stats.carWaitingTime = 0;
stats.carStopCount = 0;
stats.carCount = 0;
stats.bikeLowSpeedTime = 0;
stats.bikeTotalTime = 0;
stats.bikeWaitingTime = 0;
stats.bikeStopCount = 0;
stats.bikeCount = 0;


%% 初始化可视化
disp('初始化可视化...');
figHandle = initializeVisualization(trafficModel);

%% 运行仿真
disp('开始仿真...');
statUpdateCounter = 0;
for time = 0:CONFIG.TIME_STEP:CONFIG.SIM_TIME
    % 更新信号灯状态
    trafficLights = updateTrafficLights(trafficLights, time);
    
    % 生成新的交通参与者
    vehicles = spawnVehicles(vehicles, trafficModel, roads, time);
    
    % 更新交通参与者位置
    [vehicles, stats] = updateVehicles(vehicles, trafficModel, trafficLights, stats, time, CONFIG.TIME_STEP);
    
    % 更新统计数据（每2秒更新一次）
    statUpdateCounter = statUpdateCounter + CONFIG.TIME_STEP;
    if statUpdateCounter >= 2
        stats = updateStatistics(vehicles, trafficModel, roads, stats, time);
        statUpdateCounter = 0;
    end
    
    if ~isgraphics(figHandle)
        disp('检测到figHandle无效，重新初始化图窗...');
        figHandle = initializeVisualization(trafficModel);
    end
    % 更新可视化
    updateVisualization(figHandle, trafficModel, vehicles, trafficLights, stats, time);
    
    % 显示进度
    if mod(time, 10) < CONFIG.TIME_STEP
        fprintf('仿真进度: %0.1f%%\n', time/CONFIG.SIM_TIME*100);
    end
    
    % 暂停以模拟实时效果（可根据需要调整）
    pause(0.01);
end

%% 显示最终统计结果
displayFinalStatistics(stats);

%% 函数: 读取交通数据
function [nodes, roads] = readTrafficData(filename)
    % 读取Excel文件中的节点和道路数据
    nodeData = readtable(filename, 'Sheet', 'Sheet1', 'VariableNamingRule', 'preserve');
    roadData = readtable(filename, 'Sheet', 'Sheet2', 'VariableNamingRule', 'preserve');
    
    % 处理节点数据
    nodes = struct();
    nodes.id = nodeData{:, 1};  % 节点ID
    nodes.x = nodeData{:, 2};   % 节点横坐标
    nodes.y = nodeData{:, 3};   % 节点纵坐标
    nodes.type = nodeData{:, 4}; % 路口类型 (X, T, A, B)
    nodes.hasSignal = strcmp(nodeData{:, 5}, 'Y'); % 是否有信号灯
    
    % 将节点ID转换为字符串格式
    if ~iscell(nodes.id)
        nodes.id = cellstr(num2str(nodes.id));
    end
    
    % 处理道路数据
    roads = struct();
    roadIds = roadData{:, 1};  % 道路ID (例如 "0;1")
    
    % 将道路ID分解为起始和结束节点
    roadSplit = cellfun(@(x) strsplit(x, ';'), roadIds, 'UniformOutput', false);
    startNodes = cellfun(@(x) x{1}, roadSplit, 'UniformOutput', false);
    endNodes = cellfun(@(x) x{2}, roadSplit, 'UniformOutput', false);
    
    roads.id = roadIds;
    roads.startNode = startNodes;
    roads.endNode = endNodes;
    roads.laneCount = roadData{:, 2};  % 车道数量
    
    % 小节点到大节点的车道
    roads.smallToBigLanes = cell(size(roadIds));
    for i = 1:size(roadData, 1)
        lanes = [];
        for j = 3:6  % sbl1 to sbl4
            if j <= size(roadData, 2) && ~isnan(roadData{i, j})
                lanes = [lanes, roadData{i, j}];
            end
        end
        roads.smallToBigLanes{i} = lanes;
    end
    
    % 大节点到小节点的车道
    roads.bigToSmallLanes = cell(size(roadIds));
    for i = 1:size(roadData, 1)
        lanes = [];
        for j = 10:13  % bsl1 to bsl4
            if j <= size(roadData, 2) && ~isnan(roadData{i, j})
                lanes = [lanes, roadData{i, j}];
            end
        end
        roads.bigToSmallLanes{i} = lanes;
    end
    
    % 小到大方向的下一个可去节点
    roads.smallToBigNextNodes = cell(size(roadIds));
    for i = 1:size(roadData, 1)
        nextNodes = [];
        for j = 7:9  % sbnn1 to sbnn3
            if j <= size(roadData, 2) && ~isnan(roadData{i, j})
                nextNodes = [nextNodes, roadData{i, j}];
            end
        end
        roads.smallToBigNextNodes{i} = nextNodes;
    end
    
    % 大到小方向的下一个可去节点
    roads.bigToSmallNextNodes = cell(size(roadIds));
    for i = 1:size(roadData, 1)
        nextNodes = [];
        for j = 14:16  % bsnn1 to bsnn3
            if j <= size(roadData, 2) && ~isnan(roadData{i, j})
                nextNodes = [nextNodes, roadData{i, j}];
            end
        end
        roads.bigToSmallNextNodes{i} = nextNodes;
    end
    
    % 汽车生成车道
    roads.carGenLanes = cell(size(roadIds));
    for i = 1:size(roadData, 1)
        lanes = [];
        for j = 17:20  % gl1 to gl4
            if j <= size(roadData, 2) && ~isnan(roadData{i, j})
                lanes = [lanes, roadData{i, j}];
            end
        end
        roads.carGenLanes{i} = lanes;
    end
end

%% 函数: 建立拓扑结构模型
function model = buildTopologyModel(nodes, roads)
    % 创建交通网络拓扑结构模型
    model = struct();
    model.nodes = nodes;
    model.roads = roads;
    
    % 计算道路长度和方向
    disp(roads.id);
    disp(class(roads.id));
    numRoads = numel(roads.id);
    model.roadLength = zeros(numRoads, 1);
    model.roadDirection = zeros(numRoads, 2); % 单位方向向量[dx, dy]
    
    for i = 1:numRoads
        startIdx = find(strcmp(nodes.id, roads.startNode{i}));
        endIdx = find(strcmp(nodes.id, roads.endNode{i}));
        
        if ~isempty(startIdx) && ~isempty(endIdx)
            dx = nodes.x(endIdx) - nodes.x(startIdx);
            dy = nodes.y(endIdx) - nodes.y(startIdx);
            roadLen = sqrt(dx^2 + dy^2);
            
            model.roadLength(i) = roadLen;
            if roadLen > 0
                model.roadDirection(i, :) = [dx/roadLen, dy/roadLen];
            end
        end
    end
    
    % 计算车道信息
    model.lanes = buildLanes(model);
    
    % 计算路口信息
    model.intersections = buildIntersections(model);
    
    % 设置X和T路口的方向组
    model = setIntersectionGroups(model);
end

%% 函数: 构建车道模型
function lanes = buildLanes(model)
    global CONFIG
    % 为每条道路创建车道
    nodes = model.nodes;
    roads = model.roads;
    numRoads = numel(roads.id);
    
    lanes = struct();
    lanes.roadIndex = []; % 所属道路索引
    lanes.laneNumber = []; % 车道编号
    lanes.direction = []; % 方向 (1=小到大, -1=大到小)
    lanes.startX = []; % 起始X坐标
    lanes.startY = []; % 起始Y坐标
    lanes.endX = []; % 结束X坐标
    lanes.endY = []; % 结束Y坐标
    lanes.nextNodes = {}; % 可去的下一个节点
    lanes.isCarGenLane = []; % 是否为车辆生成车道
    
    laneCount = 0;
    
    for i = 1:numRoads
        startIdx = find(strcmp(nodes.id, roads.startNode{i}));
        endIdx = find(strcmp(nodes.id, roads.endNode{i}));
        
        if isempty(startIdx) || isempty(endIdx)
            continue;
        end
        
        % 道路起点和终点
        startX = nodes.x(startIdx);
        startY = nodes.y(startIdx);
        endX = nodes.x(endIdx);
        endY = nodes.y(endIdx);
        
        % 道路方向向量
        dx = endX - startX;
        dy = endY - startY;
        roadLen = sqrt(dx^2 + dy^2);
        dirX = dx / roadLen;
        dirY = dy / roadLen;
        
        % 垂直于道路方向的向量
        perpX = -dirY;
        perpY = dirX;
        
        % 总车道数
        totalLanes = roads.laneCount(i);
        
        % 小到大方向的车道
        smallToBigLanes = roads.smallToBigLanes{i};
        for j = 1:numel(smallToBigLanes)
            laneCount = laneCount + 1;
            laneNum = smallToBigLanes(j);
            
            % 根据车道编号计算车道位置偏移
            offset = (laneNum - 0.5 - totalLanes/2) * CONFIG.LANE_WIDTH;
            
            lanes.roadIndex(laneCount) = i;
            lanes.laneNumber(laneCount) = laneNum;
            lanes.direction(laneCount) = 1; % 小到大方向
            
            % 车道起点和终点
            lanes.startX(laneCount) = startX + perpX * offset;
            lanes.startY(laneCount) = startY + perpY * offset;
            lanes.endX(laneCount) = endX + perpX * offset;
            lanes.endY(laneCount) = endY + perpY * offset;
            
            % 下一个可去节点
            if ~isempty(roads.smallToBigNextNodes{i})
                nextNodeIds = num2cell(roads.smallToBigNextNodes{i});
                lanes.nextNodes{laneCount} = cellfun(@num2str, nextNodeIds, 'UniformOutput', false);
            else
                lanes.nextNodes{laneCount} = {};
            end
            
            % 检查是否为汽车生成车道
            lanes.isCarGenLane(laneCount) = any(roads.carGenLanes{i} == laneNum);
        end
        
        % 大到小方向的车道
        bigToSmallLanes = roads.bigToSmallLanes{i};
        for j = 1:numel(bigToSmallLanes)
            laneCount = laneCount + 1;
            laneNum = bigToSmallLanes(j);
            
            % 根据车道编号计算车道位置偏移
            offset = (laneNum - 0.5 - totalLanes/2) * CONFIG.LANE_WIDTH;
            
            lanes.roadIndex(laneCount) = i;
            lanes.laneNumber(laneCount) = laneNum;
            lanes.direction(laneCount) = -1; % 大到小方向
            
            % 车道起点和终点（注意起点和终点与小到大方向相反）
            lanes.startX(laneCount) = endX + perpX * offset;
            lanes.startY(laneCount) = endY + perpY * offset;
            lanes.endX(laneCount) = startX + perpX * offset;
            lanes.endY(laneCount) = startY + perpY * offset;
            
            % 下一个可去节点
            if ~isempty(roads.bigToSmallNextNodes{i})
                nextNodeIds = num2cell(roads.bigToSmallNextNodes{i});
                lanes.nextNodes{laneCount} = cellfun(@num2str, nextNodeIds, 'UniformOutput', false);
            else
                lanes.nextNodes{laneCount} = {};
            end
            
            % 检查是否为汽车生成车道
            lanes.isCarGenLane(laneCount) = any(roads.carGenLanes{i} == laneNum);
        end
    end
end

%% 函数: 构建路口模型
function intersections = buildIntersections(model)
    % 为每个节点创建路口模型
    nodes = model.nodes;
    roads = model.roads;
    numNodes = numel(nodes.id);
    
    intersections = struct();
    intersections.nodeIndex = 1:numNodes;
    intersections.type = nodes.type;
    intersections.hasSignal = nodes.hasSignal;
    intersections.connectedRoads = cell(numNodes, 1);
    intersections.stopLines = cell(numNodes, 1);
    
    % 计算每个节点连接的道路
    for i = 1:numel(roads.id)
        startNodeId = roads.startNode{i};
        endNodeId = roads.endNode{i};
        
        startIdx = find(strcmp(nodes.id, startNodeId));
        endIdx = find(strcmp(nodes.id, endNodeId));
        
        if ~isempty(startIdx)
            intersections.connectedRoads{startIdx} = [intersections.connectedRoads{startIdx}, i];
        end
        
        if ~isempty(endIdx)
            intersections.connectedRoads{endIdx} = [intersections.connectedRoads{endIdx}, i];
        end
    end
    
    % 计算每个路口的停车线位置
    for i = 1:numNodes
        type = nodes.type{i};
        connectedRoads = intersections.connectedRoads{i};
        
        % 根据路口类型设置停车线距离
        if strcmp(type, 'A') || strcmp(type, 'B')
            stopDistance = 3; % A型和B型路口停车线距离为3
        else
            % X型和T型路口需要计算交点
            stopDistance = calculateStopLineDistance(model, i, connectedRoads);
        end
        
        % 为每条连接的道路设置停车线
        stopLines = zeros(numel(connectedRoads), 1);
        for j = 1:numel(connectedRoads)
            stopLines(j) = stopDistance;
        end
        
        intersections.stopLines{i} = stopLines;
    end
end

%% 函数: 计算停车线距离
function stopDistance = calculateStopLineDistance(model, nodeIdx, connectedRoads)
    % 简化实现：对于X型和T型路口，计算停车线距离
    % 实际实现应根据需求文档中的交点计算方法
    
    % 默认停车线距离
    stopDistance = 5;
    
    % 这里应该实现根据交点计算的逻辑
    % ...
    
    return;
end

%% 函数: 设置路口方向组
function model = setIntersectionGroups(model)
    % 为X型和T型路口设置方向组
    nodes = model.nodes;
    numNodes = numel(nodes.id);
    
    % 初始化方向组
    model.xaGroup = cell(numNodes, 1);
    model.xbGroup = cell(numNodes, 1);
    model.mainGroup = cell(numNodes, 1);
    model.branchGroup = cell(numNodes, 1);
    
    for i = 1:numNodes
        type = nodes.type{i};
        connectedRoads = model.intersections.connectedRoads{i};
        
        if strcmp(type, 'X') && numel(connectedRoads) == 4
            % X型路口：计算方向向量之间的夹角
            dirs = calculateDirectionVectors(model, i, connectedRoads);
            
            % 计算夹角差值
            angles = zeros(6, 1);
            idx = 1;
            for j = 1:3
                for k = j+1:4
                    v1 = dirs(j, :);
                    v2 = dirs(k, :);
                    dot_product = dot(v1, v2);
                    angle = acosd(min(max(dot_product, -1), 1));
                    angles(idx) = angle;
                    idx = idx + 1;
                end
            end
            
            % 找出夹角差值最小的两组道路
            [~, sortIdx] = sort(abs(angles - 180));
            
            % 前两个是xa组
            pair1 = sortIdx(1);
            [road1, road2] = getPairRoads(pair1);
            model.xaGroup{i} = [connectedRoads(road1), connectedRoads(road2)];
            
            % 剩下的是xb组
            otherRoads = setdiff(1:4, [road1, road2]);
            model.xbGroup{i} = [connectedRoads(otherRoads(1)), connectedRoads(otherRoads(2))];
        
        elseif strcmp(type, 'T') && numel(connectedRoads) == 3
            % T型路口：计算方向向量之间的夹角
            dirs = calculateDirectionVectors(model, i, connectedRoads);
            
            % 计算夹角
            angles = zeros(3, 1);
            idx = 1;
            for j = 1:2
                for k = j+1:3
                    v1 = dirs(j, :);
                    v2 = dirs(k, :);
                    dot_product = dot(v1, v2);
                    angle = acosd(min(max(dot_product, -1), 1));
                    angles(idx) = angle;
                    idx = idx + 1;
                end
            end
            
            % 找出夹角差值最接近180度的两条道路
            [~, maxIdx] = max(abs(angles - 180));
            [road1, road2] = getPairRoads(maxIdx);
            
            % 设置主干道组
            model.mainGroup{i} = [connectedRoads(road1), connectedRoads(road2)];
            
            % 剩下的是支路
            otherRoad = setdiff(1:3, [road1, road2]);
            model.branchGroup{i} = connectedRoads(otherRoad);
        end
    end
end

%% 函数: 计算方向向量
function dirs = calculateDirectionVectors(model, nodeIdx, connectedRoads)
    % 计算从节点到连接道路的方向向量
    nodes = model.nodes;
    roads = model.roads;
    
    nodeX = nodes.x(nodeIdx);
    nodeY = nodes.y(nodeIdx);
    
    numRoads = numel(connectedRoads);
    dirs = zeros(numRoads, 2);
    
    for i = 1:numRoads
        roadIdx = connectedRoads(i);
        startNodeId = roads.startNode{roadIdx};
        endNodeId = roads.endNode{roadIdx};
        
        startIdx = find(strcmp(nodes.id, startNodeId));
        endIdx = find(strcmp(nodes.id, endNodeId));
        
        % 选择另一端的节点计算方向
        if startIdx == nodeIdx
            otherX = nodes.x(endIdx);
            otherY = nodes.y(endIdx);
        else
            otherX = nodes.x(startIdx);
            otherY = nodes.y(startIdx);
        end
        
        % 计算方向向量
        dx = otherX - nodeX;
        dy = otherY - nodeY;
        len = sqrt(dx^2 + dy^2);
        
        if len > 0
            dirs(i, :) = [dx/len, dy/len];
        end
    end
end

%% 函数: 获取夹角对应的道路索引
function [road1, road2] = getPairRoads(pairIdx)
    % 根据夹角索引获取对应的两条道路索引
    pairs = [
        1, 2;
        1, 3;
        1, 4;
        2, 3;
        2, 4;
        3, 4
    ];
    
    road1 = pairs(pairIdx, 1);
    road2 = pairs(pairIdx, 2);
end

%% 函数: 初始化信号灯
function trafficLights = initializeTrafficLights(model)
    global CONFIG
    % 初始化各路口的信号灯
    nodes = model.nodes;
    numNodes = numel(nodes.id);
    
    trafficLights = struct();
    trafficLights.nodeIndex = find(model.intersections.hasSignal);
    trafficLights.type = cell(numNodes, 1);
    trafficLights.phase = zeros(numNodes, 1);
    trafficLights.timer = rand(numNodes, 1) * CONFIG.SIGNAL_CYCLE; % 初始随机相位
    trafficLights.pedPhase = false(numNodes, 1);
    trafficLights.pedPhaseTimer = zeros(numNodes, 1);
    
    % 设置信号灯类型
    for i = 1:numNodes
        if model.intersections.hasSignal(i)
            trafficLights.type{i} = nodes.type{i};
        else
            trafficLights.type{i} = '';
        end
    end
end

%% 函数: 更新信号灯状态
function trafficLights = updateTrafficLights(trafficLights, time)
    global CONFIG
    % 更新各路口信号灯的状态
    numNodes = numel(trafficLights.nodeIndex);
    
    for i = 1:numNodes
        nodeIdx = trafficLights.nodeIndex(i);
        type = trafficLights.type{nodeIdx};
        
        % 如果正在执行行人通行相位
        if trafficLights.pedPhase(nodeIdx)
            trafficLights.pedPhaseTimer(nodeIdx) = trafficLights.pedPhaseTimer(nodeIdx) + CONFIG.TIME_STEP;
            
            % 根据路口类型设置行人相位持续时间
            if strcmp(type, 'X')
                pedDuration = 30;
            elseif strcmp(type, 'T')
                pedDuration = 20;
            else  % A型路口
                pedDuration = 10;
            end
            
            % 行人相位结束
            if trafficLights.pedPhaseTimer(nodeIdx) >= pedDuration
                trafficLights.pedPhase(nodeIdx) = false;
                trafficLights.pedPhaseTimer(nodeIdx) = 0;
                trafficLights.timer(nodeIdx) = 0;  % 重置常规相位计时器
            end
            
            continue;  % 跳过常规相位更新
        end
        
        % 更新常规相位计时器
        trafficLights.timer(nodeIdx) = trafficLights.timer(nodeIdx) + CONFIG.TIME_STEP;
        
        % 相位切换逻辑
        if trafficLights.timer(nodeIdx) >= CONFIG.SIGNAL_CYCLE
            trafficLights.timer(nodeIdx) = 0;
            
            % 根据路口类型更新相位
            if strcmp(type, 'X')
                trafficLights.phase(nodeIdx) = mod(trafficLights.phase(nodeIdx) + 1, 5);
            elseif strcmp(type, 'T')
                trafficLights.phase(nodeIdx) = mod(trafficLights.phase(nodeIdx) + 1, 3);
            else  % A型路口
                trafficLights.phase(nodeIdx) = 0;  % 只有一个相位
            end
            
            % 检查是否触发行人通行相位
            if rand < CONFIG.PED_PHASE_PROB
                trafficLights.pedPhase(nodeIdx) = true;
            end
        end
    end
end

%% 函数: 生成新车辆
function vehicles = spawnVehicles(vehicles, model, roads, time)
    global CONFIG
    % 根据生成概率生成新车辆
    lanes = model.lanes;
    
    % 找出所有可以生成车辆的车道
    carGenLaneIndices = find(lanes.isCarGenLane);
    
    if isempty(carGenLaneIndices)
        return;
    end
    
    % 根据生成概率决定是否生成新车辆
    if rand < CONFIG.SPAWN_RATE * CONFIG.TIME_STEP
        % 随机选择一条生成车道
        laneIdx = carGenLaneIndices(randi(numel(carGenLaneIndices)));
        
        % 决定生成汽车还是自行车（5:1比例）
        if rand < CONFIG.CAR_TO_BIKE_RATIO / (CONFIG.CAR_TO_BIKE_RATIO + 1)
            type = 'car';
        else
            type = 'bike';
        end
        
        % 检查车道上是否有足够空间生成新车辆
        isClear = isLaneClear(vehicles, laneIdx, lanes.startX(laneIdx), lanes.startY(laneIdx), type);
        
        if isClear
            % 创建新车辆
            newVehicle = struct();
            newVehicle.id = numel(vehicles) + 1;
            newVehicle.type = type;
            newVehicle.laneIdx = laneIdx;
            newVehicle.x = lanes.startX(laneIdx);
            newVehicle.y = lanes.startY(laneIdx);
            newVehicle.direction = lanes.direction(laneIdx);
            newVehicle.speed = 3;
            newVehicle.acceleration = 0;
            newVehicle.distance = 0;  % 在当前车道上行驶的距离
            newVehicle.nextNodeIdx = []; % 下一个节点索引，暂未确定
            newVehicle.status = 'moving';  % 状态：moving, waiting, stopped
            newVehicle.waitingTime = 0;
            newVehicle.stopCount = 0;
            newVehicle.totalTime = 0;
            newVehicle.lowSpeedTime = 0;
            
            % 根据车辆类型设置最大速度和尺寸
            if strcmp(type, 'car')
                newVehicle.maxSpeed = CONFIG.CAR_MAX_SPEED;
                newVehicle.maxAccel = CONFIG.CAR_MAX_ACCEL;
                newVehicle.maxDecel = CONFIG.CAR_MAX_DECEL;
                newVehicle.length = CONFIG.CAR_LENGTH;
                newVehicle.width = CONFIG.CAR_WIDTH;
            else  % bike
                newVehicle.maxSpeed = CONFIG.BIKE_MAX_SPEED;
                newVehicle.maxAccel = CONFIG.BIKE_MAX_ACCEL;
                newVehicle.maxDecel = CONFIG.BIKE_MAX_DECEL;
                newVehicle.length = CONFIG.BIKE_LENGTH;
                newVehicle.width = CONFIG.BIKE_WIDTH;
            end
            
            % 添加新车辆到列表
            vehicles = [vehicles, newVehicle];
        end
    end
    
    % 根据生成概率决定是否生成自行车
    % 自行车可以在任意车道中心线和路口线上交点生成
    if rand < CONFIG.SPAWN_RATE * CONFIG.TIME_STEP / CONFIG.CAR_TO_BIKE_RATIO
        % 随机选择一条车道
        laneIdx = randi(numel(lanes.roadIndex));
        
        % 检查车道上是否有足够空间生成新自行车
        isClear = isLaneClear(vehicles, laneIdx, lanes.startX(laneIdx), lanes.startY(laneIdx), 'bike');
        
        if isClear
            % 创建新自行车
            newBike = struct();
            newBike.id = numel(vehicles) + 1;
            newBike.type = 'bike';
            newBike.laneIdx = laneIdx;
            newBike.x = lanes.startX(laneIdx);
            newBike.y = lanes.startY(laneIdx);
            newBike.direction = lanes.direction(laneIdx);
            newBike.speed = 0;
            newBike.acceleration = 0;
            newBike.distance = 0;
            newBike.nextNodeIdx = [];
            newBike.status = 'moving';
            newBike.waitingTime = 0;
            newBike.stopCount = 0;
            newBike.totalTime = 0;
            newBike.lowSpeedTime = 0;
            
            % 设置自行车参数
            newBike.maxSpeed = CONFIG.BIKE_MAX_SPEED;
            newBike.maxAccel = CONFIG.BIKE_MAX_ACCEL;
            newBike.maxDecel = CONFIG.BIKE_MAX_DECEL;
            newBike.length = CONFIG.BIKE_LENGTH;
            newBike.width = CONFIG.BIKE_WIDTH;
            
            % 添加新自行车到列表
            vehicles = [vehicles, newBike];
        end
    end
end

%% 函数: 检查车道是否有足够空间生成车辆
function clear = isLaneClear(vehicles, laneIdx, x, y, type)
    global CONFIG
    % 检查在指定位置是否有足够空间生成新车辆
    if strcmp(type, 'car')
        vehicleLen = CONFIG.CAR_LENGTH;
    else
        vehicleLen = CONFIG.BIKE_LENGTH;
    end
    
    % 检查该车道上的所有车辆
    for i = 1:numel(vehicles)
        if vehicles(i).laneIdx == laneIdx
            % 计算到起点的距离
            dx = vehicles(i).x - x;
            dy = vehicles(i).y - y;
            distance = sqrt(dx^2 + dy^2);
            
            % 如果距离小于安全距离，则无法生成
            if distance < vehicleLen + CONFIG.SAFE_DISTANCE_MIN
                clear = false;
                return;
            end
        end
    end
    
    clear = true;
end

%% 函数: 更新车辆位置
function [vehicles, stats] = updateVehicles(vehicles, model, trafficLights, stats, time, deltaTime)
    global CONFIG
    % 更新所有车辆的位置和状态
    lanes = model.lanes;
    nodes = model.nodes;
    roads = model.roads;
    
    % 如果没有车辆，直接返回
    if isempty(vehicles)
        return;
    end
    
    % 创建一个标记数组，用于记录哪些车辆需要被移除
    removeFlag = false(size(vehicles));
    
    % 更新每个车辆
    for i = 1:numel(vehicles)
        % 更新车辆总时间
        vehicles(i).totalTime = vehicles(i).totalTime + deltaTime;
        
        % 获取当前车道信息
        laneIdx = vehicles(i).laneIdx;
        roadIdx = lanes.roadIndex(laneIdx);
        laneDirection = lanes.direction(laneIdx);
        
        % 计算车辆到车道终点的距离
        endX = lanes.endX(laneIdx);
        endY = lanes.endY(laneIdx);
        dx = endX - vehicles(i).x;
        dy = endY - vehicles(i).y;
        distanceToEnd = sqrt(dx^2 + dy^2);
        
        % 确定车辆是否接近路口
        approachingIntersection = distanceToEnd < 10;  % 10米内视为接近路口
        
        % 获取前方车辆
        leadVehicle = findLeadVehicle(vehicles, i, laneIdx);
        
        % 计算安全距离
        safeDistance = CONFIG.SAFE_DISTANCE_MIN + vehicles(i).speed * CONFIG.HEADWAY_TIME;
        
        if ~isempty(leadVehicle)
            leadDistance = sqrt((leadVehicle.x - vehicles(i).x)^2 + (leadVehicle.y - vehicles(i).y)^2) - vehicles(i).length/2 - leadVehicle.length/2;
        else
            leadDistance = inf;
        end
        
        % 确定终点节点
        if laneDirection == 1
            endNodeId = roads.endNode{roadIdx};
        else
            endNodeId = roads.startNode{roadIdx};
        end
        endNodeIdx = find(strcmp(nodes.id, endNodeId));
        
        % 决定车辆加速度
        targetAccel = 0;
        
        if approachingIntersection
            % 检查是否可以通过路口
            canPassIntersection = isAllowedToGo(vehicles(i), model, trafficLights, endNodeIdx);
            
            if canPassIntersection
                % 可以通过路口
                if leadDistance < safeDistance
                    % 前方车辆距离过近，需要减速
                    targetAccel = -vehicles(i).maxDecel * min(1, (safeDistance - leadDistance) / safeDistance);
                    
                    if vehicles(i).speed < 0.1 && leadDistance < CONFIG.SAFE_DISTANCE_MIN
                        vehicles(i).status = 'stopped';
                        vehicles(i).speed = 0;
                        vehicles(i).acceleration = 0;
                        
                        if vehicles(i).speed > 0
                            vehicles(i).stopCount = vehicles(i).stopCount + 1;
                        end
                    end
                else
                    % 可以通过路口且前方没有车辆阻挡
                    targetAccel = vehicles(i).maxAccel * (1 - vehicles(i).speed / vehicles(i).maxSpeed);
                    vehicles(i).status = 'moving';
                end
            else
                % 不能通过路口
                if distanceToEnd < 2  % 接近停止线
                    vehicles(i).status = 'waiting';
                    vehicles(i).waitingTime = vehicles(i).waitingTime + deltaTime;
                    
                    if vehicles(i).speed < 0.1
                        vehicles(i).status = 'stopped';
                        vehicles(i).speed = 0;
                        vehicles(i).acceleration = 0;
                        
                        if vehicles(i).speed > 0
                            vehicles(i).stopCount = vehicles(i).stopCount + 1;
                        end
                    else
                        targetAccel = -vehicles(i).maxDecel * 0.8;  % 适当减速
                    end
                else
                    %接近路口但还未到停止线
                    if leadDistance < safeDistance
                        % 前方车辆距离过近
                        targetAccel = -vehicles(i).maxDecel * min(1, (safeDistance - leadDistance) / safeDistance);
                    else
                        % 减速接近路口
                        targetAccel = -vehicles(i).maxDecel * min(1, distanceToEnd / 10);
                    end
                    vehicles(i).status = 'approaching';
                end
            end
            
            % 到达终点，需要选择下一个节点
            if distanceToEnd < 0.5
                % the distanceToEnd < 0.5会认为已经到达终点，在前面的代码中应该调整为防止车辆在终点停下，
                % 但这里保留，假设车辆能到达终点
                % 获取当前节点类型
                nodeType = nodes.type{endNodeIdx};
                
                % 补充定义当前节点ID 
                if laneDirection == 1
                    currentNodeId = roads.endNode{roadIdx};
                else
                    currentNodeId = roads.startNode{roadIdx};
                end
                possibleNextNodes = lanes.nextNodes{laneIdx};
                
                if isempty(possibleNextNodes)
                    % 若没有明确指定，则移除
                    vehicles(i).status = 'removed';
                    removeFlag(i) = true;
                else
                    nextNodeId = possibleNextNodes{randi(numel(possibleNextNodes))};
                
                    % 找到连接该节点的下一车道
                    nextLaneIdx = findNextLane(model, currentNodeId, nextNodeId, vehicles(i).type);
                
                    if isempty(nextLaneIdx)
                        % 若未找到连接车道，移除车辆
                        vehicles(i).status = 'removed';
                        removeFlag(i) = true;
                    else
                        % 严格设置在新车道起点
                        vehicles(i).laneIdx = nextLaneIdx;
                        vehicles(i).x = lanes.startX(nextLaneIdx);
                        vehicles(i).y = lanes.startY(nextLaneIdx);
                        vehicles(i).direction = lanes.direction(nextLaneIdx);
                        vehicles(i).distance = 0; % 重置距离
                        vehicles(i).nextNodeIdx = [];
                    end
                end

                % 对于B型节点，车辆离开路网
                if strcmp(nodeType, 'B')
                    % 更新统计数据
                    if strcmp(vehicles(i).type, 'car')
                        stats.carCount = stats.carCount + 1;
                        stats.carLowSpeedTime = stats.carLowSpeedTime + vehicles(i).lowSpeedTime;
                        stats.carTotalTime = stats.carTotalTime + vehicles(i).totalTime;
                        stats.carWaitingTime = stats.carWaitingTime + vehicles(i).waitingTime;
                        stats.carStopCount = stats.carStopCount + vehicles(i).stopCount;
                    else
                        stats.bikeCount = stats.bikeCount + 1;
                        stats.bikeLowSpeedTime = stats.bikeLowSpeedTime + vehicles(i).lowSpeedTime;
                        stats.bikeTotalTime = stats.bikeTotalTime + vehicles(i).totalTime;
                        stats.bikeWaitingTime = stats.bikeWaitingTime + vehicles(i).waitingTime;
                        stats.bikeStopCount = stats.bikeStopCount + vehicles(i).stopCount;
                    end
                    
                    % 标记车辆移除
                    vehicles(i).status = 'removed';
                    removeFlag(i) = true;
                    continue;
                end
                
                % 对于Bike，有概率离开路网
                if strcmp(vehicles(i).type, 'bike') && rand < 0.05
                    % 更新统计数据
                    stats.bikeCount = stats.bikeCount + 1;
                    stats.bikeLowSpeedTime = stats.bikeLowSpeedTime + vehicles(i).lowSpeedTime;
                    stats.bikeTotalTime = stats.bikeTotalTime + vehicles(i).totalTime;
                    stats.bikeWaitingTime = stats.bikeWaitingTime + vehicles(i).waitingTime;
                    stats.bikeStopCount = stats.bikeStopCount + vehicles(i).stopCount;
                    
                    % 标记车辆移除
                    vehicles(i).status = 'removed';
                    removeFlag(i) = true;
                    continue;
                end
            end
        else
            % 在道路中段
            if leadDistance < safeDistance
                % 前方车辆距离过近，需要减速
                targetAccel = -vehicles(i).maxDecel * min(1, (safeDistance - leadDistance) / safeDistance);
                
                if vehicles(i).speed < 0.1 && leadDistance < CONFIG.SAFE_DISTANCE_MIN
                    vehicles(i).status = 'stopped';
                    if vehicles(i).speed > 0
                        vehicles(i).stopCount = vehicles(i).stopCount + 1;
                    end
                    targetAccel = 0;
                    vehicles(i).speed = 0;
                end
            else
                % 正常行驶，加速到最大速度
                targetAccel = vehicles(i).maxAccel * (1 - vehicles(i).speed / vehicles(i).maxSpeed);
                vehicles(i).status = 'moving';
            end
        end
        
        % 应用加速度限制
        vehicles(i).acceleration = max(-vehicles(i).maxDecel, min(vehicles(i).maxAccel, targetAccel));
        
        % 更新速度
        vehicles(i).speed = max(0, vehicles(i).speed + vehicles(i).acceleration * deltaTime);
        
        % 统计低速时间
        if vehicles(i).speed < vehicles(i).maxSpeed / 3
            vehicles(i).lowSpeedTime = vehicles(i).lowSpeedTime + deltaTime;
        end
        
        % 更新位置
        if vehicles(i).speed > 0
            % 计算移动方向
            dirX = (lanes.endX(laneIdx) - lanes.startX(laneIdx));
            dirY = (lanes.endY(laneIdx) - lanes.startY(laneIdx));
            dist = sqrt(dirX^2 + dirY^2);
            
            if dist > 0
                dirX = dirX / dist;
                dirY = dirY / dist;
                
                % 更新位置
                moveDistance = vehicles(i).speed * deltaTime;
                vehicles(i).x = vehicles(i).x + dirX * moveDistance;
                vehicles(i).y = vehicles(i).y + dirY * moveDistance;
                vehicles(i).distance = vehicles(i).distance + moveDistance;
            end
        end
    end
    
    % 移除标记为removed的车辆
    if ~isempty(vehicles)
        vehicles = vehicles(~removeFlag);
    end
end

%% 函数: 查找前方车辆
function leadVehicle = findLeadVehicle(vehicles, vehicleIdx, laneIdx)
    % 找出当前车道上的前方车辆
    vehicle = vehicles(vehicleIdx);
    minDistance = inf;
    leadVehicle = [];
    
    for i = 1:numel(vehicles)
        if i ~= vehicleIdx && vehicles(i).laneIdx == laneIdx
            % 计算两车之间的距离
            dx = vehicles(i).x - vehicle.x;
            dy = vehicles(i).y - vehicle.y;
            distance = sqrt(dx^2 + dy^2);
            
            % 检查是否在前方
            dirX = (dx > 0 && vehicle.direction > 0) || (dx < 0 && vehicle.direction < 0);
            dirY = (dy > 0 && vehicle.direction > 0) || (dy < 0 && vehicle.direction < 0);
            
            if (dirX || dirY) && distance < minDistance
                minDistance = distance;
                leadVehicle = vehicles(i);
            end
        end
    end
end

%% 函数: 查找下一个车道
function nextLaneIdx = findNextLane(model, currentNodeId, nextNodeId, vehicleType)
    % 找出通往下一个节点的可用车道
    lanes = model.lanes;
    roads = model.roads;
    
    % 查找连接当前节点和下一个节点的道路
    roadIdx = [];
    for i = 1:numel(roads.id)
        if (strcmp(roads.startNode{i}, currentNodeId) && strcmp(roads.endNode{i}, nextNodeId)) || ...
           (strcmp(roads.startNode{i}, nextNodeId) && strcmp(roads.endNode{i}, currentNodeId))
            roadIdx = i;
            break;
        end
    end
    
    if isempty(roadIdx)
        nextLaneIdx = [];
        return;
    end
    
    % 确定车道方向
    if strcmp(roads.startNode{roadIdx}, currentNodeId)
        direction = 1;  % 小到大方向
        possibleLanes = roads.smallToBigLanes{roadIdx};
    else
        direction = -1; % 大到小方向
        possibleLanes = roads.bigToSmallLanes{roadIdx};
    end
    
    % 查找所有符合条件的车道
    validLanes = [];
    for i = 1:numel(lanes.roadIndex)
        if lanes.roadIndex(i) == roadIdx && lanes.direction(i) == direction
            validLanes = [validLanes, i];
        end
    end
    
    if isempty(validLanes)
        nextLaneIdx = [];
    else
        % 随机选择一条有效车道
        nextLaneIdx = validLanes(randi(numel(validLanes)));
    end
end

%% 函数: 检查是否可以通过路口
%% 函数: 检查是否可以通过路口
function allowed = isAllowedToGo(vehicle, model, trafficLights, nodeIdx)
    % 检查车辆是否可以通过路口（信号灯和让行规则）
    
    % 首先检查该节点是否有信号灯
    if ~model.intersections.hasSignal(nodeIdx)
        % 如果没有信号灯，使用默认的让行规则
        allowed = true;
        return;
    end
    
    % 检查行人相位
    if trafficLights.pedPhase(nodeIdx)
        allowed = false;
        return;
    end
    
    % 获取路口类型和相位
    type = trafficLights.type{nodeIdx};
    phase = trafficLights.phase(nodeIdx);
    
    % 获取车辆所在的车道和道路
    laneIdx = vehicle.laneIdx;
    roadIdx = model.lanes.roadIndex(laneIdx);
    
    % 根据路口类型和当前相位判断
    if strcmp(type, 'X')
        % X型路口相位逻辑
        % 相位说明:
        % 0: 全红
        % 1: xa组直行和左转
        % 2: xb组直行和左转
        % 3: xa组右转
        % 4: xb组右转
        
        % 找出车辆所在道路是否属于xa组或xb组
        isXaGroup = any(model.xaGroup{nodeIdx} == roadIdx);
        isXbGroup = any(model.xbGroup{nodeIdx} == roadIdx);
        
        % 判断是直行、左转还是右转
        % 简化处理：随机分配动作，实际应基于下一个节点位置计算
        action = randi(3);  % 1=直行, 2=左转, 3=右转
        
        if phase == 0
            % 全红相位，所有车辆停止
            allowed = false;
        elseif isXaGroup
            if (phase == 1 && (action == 1 || action == 2)) || (phase == 3 && action == 3)
                allowed = true;
            else
                allowed = false;
            end
        elseif isXbGroup
            if (phase == 2 && (action == 1 || action == 2)) || (phase == 4 && action == 3)
                allowed = true;
            else
                allowed = false;
            end
        else
            % 如果不属于任何组，默认不允许通行
            allowed = false;
        end
        
    elseif strcmp(type, 'T')
        % T型路口相位逻辑
        % 相位说明:
        % 0: 支路转向
        % 1: 主干道直行和左转
        % 2: 主干道直行和右转
        
        % 找出车辆所在道路是否属于main组或branch组
        isMainGroup = any(model.mainGroup{nodeIdx} == roadIdx);
        isBranchGroup = any(model.branchGroup{nodeIdx} == roadIdx);
        
        % 简化：随机分配直行/左转/右转
        action = randi(3);  % 1=直行, 2=左转, 3=右转
        
        if isMainGroup
            if (phase == 1 && (action == 1 || action == 2)) || ...
               (phase == 2 && (action == 1 || action == 3))
                allowed = true;
            else
                allowed = false;
            end
        elseif isBranchGroup
            if phase == 0
                allowed = true;
            else
                allowed = false;
            end
        else
            % 如果不属于任何组，默认不允许通行
            allowed = false;
        end
        
    else  % A型路口
        % A型路口只有一个相位，总是允许通行
        allowed = true;
    end
end

%% 函数: 更新统计数据
function stats = updateStatistics(vehicles, model, roads, stats, time)
    % 更新各项统计数据
    
    % 计算当前时间点的统计索引
    timeIdx = ceil(time / 2);
    if timeIdx < 1
        timeIdx = 1;
    end
    
    % 计算各道路的承载量指数
    numRoads = numel(roads.id);
    roadCapacity = zeros(numRoads, 1);
    
    for i = 1:numRoads
        % 获取该道路的所有车道
        roadLanes = find([model.lanes.roadIndex] == i);
        
        if isempty(roadLanes)
            continue;
        end
        
        % 计算总车道长度
        totalLaneLength = model.roadLength(i) * roads.laneCount(i);
        
        % 计算该道路上的车辆总长度
        vehicleLength = 0;
        for j = 1:numel(vehicles)
            if ismember(vehicles(j).laneIdx, roadLanes)
                vehicleLength = vehicleLength + vehicles(j).length;
            end
        end
        
        % 计算承载量指数
        if totalLaneLength > 0
            roadCapacity(i) = vehicleLength / totalLaneLength;
        end
    end
    
    % 保存道路承载量数据
    if timeIdx <= size(stats.roadCapacity, 2)
        stats.roadCapacity(:, timeIdx) = roadCapacity;
    end
    
    % 计算平均承载量和方差
    avgCapacity = mean(roadCapacity);
    varCapacity = var(roadCapacity);
    
    % 打印当前统计数据
    fprintf('时间 %.1f秒:\n', time);
    fprintf('  道路平均承载量: %.2f\n', avgCapacity);
    fprintf('  道路承载量方差: %.2f\n', varCapacity);
    
    % 计算车辆统计数据
    if stats.carCount > 0
        carLowSpeedRatio = stats.carLowSpeedTime / stats.carTotalTime;
        carAvgWaitTime = stats.carWaitingTime / stats.carCount;
        carAvgStopCount = stats.carStopCount / stats.carCount;
        
        fprintf('  汽车低速时间占比: %.2f%%\n', carLowSpeedRatio * 100);
        fprintf('  汽车平均等待时间: %.2f秒\n', carAvgWaitTime);
        fprintf('  汽车平均停车次数: %.2f次\n', carAvgStopCount);
    end
    
    if stats.bikeCount > 0
        bikeLowSpeedRatio = stats.bikeLowSpeedTime / stats.bikeTotalTime;
        bikeAvgWaitTime = stats.bikeWaitingTime / stats.bikeCount;
        bikeAvgStopCount = stats.bikeStopCount / stats.bikeCount;
        
        fprintf('  自行车低速时间占比: %.2f%%\n', bikeLowSpeedRatio * 100);
        fprintf('  自行车平均等待时间: %.2f秒\n', bikeAvgWaitTime);
        fprintf('  自行车平均停车次数: %.2f次\n', bikeAvgStopCount);
    end
    
    if ~isempty(vehicles)
        fprintf('  当前车辆数: %d (汽车: %d, 自行车: %d)\n', ...
            numel(vehicles), ...
            sum(strcmp({vehicles.type}, 'car')), ...
            sum(strcmp({vehicles.type}, 'bike')));
    else
        fprintf('  当前车辆数: 0 (汽车: 0, 自行车: 0)\n');
    end
end

%% 函数: 初始化可视化
function figHandle = initializeVisualization(model)
    global CONFIG
    % 创建图形窗口和初始化可视化
    figHandle = figure('Name', '交通仿真', 'Position', [100, 100, 1200, 800]);
    
    % 创建子图
    subplot(1, 1, 1);
    hold on;
    axis equal;
    title('交通网络仿真');
    
    % 绘制节点
    nodes = model.nodes;
    plot(nodes.x, nodes.y, 'ko', 'MarkerSize', 8, 'MarkerFaceColor', 'k');
    
    % 绘制道路和车道
    roads = model.roads;
    for i = 1:numel(roads.id)
        % 获取道路起点和终点节点
        startNodeId = roads.startNode{i};
        endNodeId = roads.endNode{i};
        
        startIdx = find(strcmp(nodes.id, startNodeId));
        endIdx = find(strcmp(nodes.id, endNodeId));
        
        if isempty(startIdx) || isempty(endIdx)
            continue;
        end
        
        % 道路起点和终点
        startX = nodes.x(startIdx);
        startY = nodes.y(startIdx);
        endX = nodes.x(endIdx);
        endY = nodes.y(endIdx);
        
        % 道路方向向量
        dx = endX - startX;
        dy = endY - startY;
        roadLen = sqrt(dx^2 + dy^2);
        dirX = dx / roadLen;
        dirY = dy / roadLen;
        
        % 垂直于道路方向的向量
        perpX = -dirY;
        perpY = dirX;
        
        % 道路宽度（基于车道数）
        roadWidth = roads.laneCount(i) * CONFIG.LANE_WIDTH;
        
        % 绘制道路边界
        leftX = [startX + perpX * roadWidth/2, endX + perpX * roadWidth/2];
        leftY = [startY + perpY * roadWidth/2, endY + perpY * roadWidth/2];
        rightX = [startX - perpX * roadWidth/2, endX - perpX * roadWidth/2];
        rightY = [startY - perpY * roadWidth/2, endY - perpY * roadWidth/2];
        
        plot(leftX, leftY, 'k-', 'LineWidth', 1.5);
        plot(rightX, rightY, 'k-', 'LineWidth', 1.5);
        
        % 绘制车道分割线
        for j = 1:(roads.laneCount(i) - 1)
            offset = (j - roads.laneCount(i)/2) * CONFIG.LANE_WIDTH;
            laneX = [startX + perpX * offset, endX + perpX * offset];
            laneY = [startY + perpY * offset, endY + perpY * offset];
            
            plot(laneX, laneY, 'k--', 'LineWidth', 0.5);
        end
    end
    
    % 绘制路口线
    for i = 1:numel(model.intersections.nodeIndex)
        nodeIdx = model.intersections.nodeIndex(i);
        nodeType = model.nodes.type{nodeIdx};
        connectedRoads = model.intersections.connectedRoads{i};
        stopLines = model.intersections.stopLines{i};
        
        for j = 1:numel(connectedRoads)
            roadIdx = connectedRoads(j);
            stopDist = stopLines(j);
            
            % 获取道路信息
            startNodeId = roads.startNode{roadIdx};
            endNodeId = roads.endNode{roadIdx};
            
            startIdx = find(strcmp(nodes.id, startNodeId));
            endIdx = find(strcmp(nodes.id, endNodeId));
            
            if isempty(startIdx) || isempty(endIdx)
                continue;
            end
            
            % 确定节点是路的起点还是终点
            if nodeIdx == startIdx
                otherIdx = endIdx;
                isStart = true;
            else
                otherIdx = startIdx;
                isStart = false;
            end
            
            % 计算方向向量
            dirX = nodes.x(otherIdx) - nodes.x(nodeIdx);
            dirY = nodes.y(otherIdx) - nodes.y(nodeIdx);
            dist = sqrt(dirX^2 + dirY^2);
            
            if dist > 0
                dirX = dirX / dist;
                dirY = dirY / dist;
                
                % 计算停车线的位置
                stopX = nodes.x(nodeIdx) + dirX * stopDist;
                stopY = nodes.y(nodeIdx) + dirY * stopDist;
                
                % 垂直于道路方向的向量
                perpX = -dirY;
                perpY = dirX;
                
                % 道路宽度
                roadWidth = roads.laneCount(roadIdx) * CONFIG.LANE_WIDTH;
                
                % 绘制停车线
                line1X = stopX + perpX * roadWidth/2;
                line1Y = stopY + perpY * roadWidth/2;
                line2X = stopX - perpX * roadWidth/2;
                line2Y = stopY - perpY * roadWidth/2;
                
                plot([line1X, line2X], [line1Y, line2Y], 'r-', 'LineWidth', 2);
            end
        end
    end
    
    % 设置图形范围
    minX = min(nodes.x) - 20;
    maxX = max(nodes.x) + 20;
    minY = min(nodes.y) - 20;
    maxY = max(nodes.y) + 20;
    
    axis([minX, maxX, minY, maxY]);
    
    % 创建图例
    legend('节点', '道路边界', '车道分隔线', '停车线', 'Location', 'northeast');
    
    % 添加统计数据文本
    annotation('textbox', [0.01, 0.01, 0.3, 0.15], 'String', '', 'EdgeColor', 'none', 'Tag', 'statsText');
    
    drawnow;
end

%% 函数: 更新可视化
function updateVisualization(figHandle, model, vehicles, trafficLights, stats, time)
    global CONFIG
    % 更新仿真可视化
    
    % 切换到图形窗口
    figure(figHandle);
    
    % 清除之前的车辆绘图
    vehicleHandles = findobj(gca, 'Tag', 'vehicle');
    if ~isempty(vehicleHandles)
        delete(vehicleHandles);
    end
    
    % 清除之前的信号灯绘图
    signalHandles = findobj(gca, 'Tag', 'signal');
    if ~isempty(signalHandles)
        delete(signalHandles);
    end
    
    % 绘制车辆
    for i = 1:numel(vehicles)
        vehicle = vehicles(i);
        
        % 根据车辆类型设置颜色和大小
        if strcmp(vehicle.type, 'car')
            color = 'b';
            width = vehicle.width;
            vehicleLen = vehicle.length;
        else  % bike
            color = 'g';
            width = vehicle.width;
            vehicleLen = vehicle.length;
        end
        
        % 绘制车辆（简化为矩形）
        rectangle('Position', [vehicle.x - vehicleLen/2, vehicle.y - width/2, vehicleLen, width], ...
                 'Curvature', [0.2, 0.2], 'FaceColor', color, 'Tag', 'vehicle');
    end
    
    % 绘制信号灯状态
    nodes = model.nodes;
    for i = 1:numel(trafficLights.nodeIndex)
        nodeIdx = trafficLights.nodeIndex(i);
        phase = trafficLights.phase(nodeIdx);
        type = trafficLights.type{nodeIdx};
        
        % 确定信号灯颜色
        if trafficLights.pedPhase(nodeIdx)
            color = [1, 0.5, 0];  % 橙色表示行人相位
        else
            if strcmp(type, 'X')
                % X型路口相位颜色
                switch phase
                    case 0  % 全红
                        color = 'r';
                    case 1  % xa的直行和左转
                        color = [0, 0.7, 0];  % 深绿色
                    case 2  % xb的直行和左转
                        color = [0, 0.5, 0];  % 浅绿色
                    case 3  % xa右转
                        color = [0, 0.9, 0.9];  % 青色
                    case 4  % xb右转
                        color = [0, 0.7, 0.7];  % 深青色
                end
            elseif strcmp(type, 'T')
                % T型路口相位颜色
                switch phase
                    case 0  % br转向
                        color = [0.8, 0.8, 0];  % 黄色
                    case 1  % m直行和左转
                        color = [0, 0.7, 0];  % 深绿色
                    case 2  % m直行和右转
                        color = [0, 0.5, 0];  % 浅绿色
                end
            else  % A型路口
                color = [0, 0.7, 0];  % 绿色
            end
        end
        
        % 在节点位置绘制信号灯圆圈
        plot(nodes.x(nodeIdx), nodes.y(nodeIdx), 'o', 'MarkerSize', 12, ...
             'MarkerEdgeColor', 'k', 'MarkerFaceColor', color, 'Tag', 'signal');
    end
    
    % 更新统计数据显示
    statsText = sprintf('仿真时间: %.1f秒\n', time);
    
    % 计算平均承载量
    timeIdx = ceil(time / 2);
    if timeIdx >= 1 && timeIdx <= size(stats.roadCapacity, 2)
        avgCapacity = mean(stats.roadCapacity(:, timeIdx));
        varCapacity = var(stats.roadCapacity(:, timeIdx));
        statsText = [statsText, sprintf('道路平均承载量: %.2f\n', avgCapacity)];
        statsText = [statsText, sprintf('道路承载量方差: %.2f\n', varCapacity)];
    end
    
    % 车辆统计
    if stats.carCount > 0
        carLowSpeedRatio = stats.carLowSpeedTime / stats.carTotalTime;
        carAvgWaitTime = stats.carWaitingTime / stats.carCount;
        carAvgStopCount = stats.carStopCount / stats.carCount;
        
        statsText = [statsText, sprintf('汽车低速时间占比: %.2f%%\n', carLowSpeedRatio * 100)];
        statsText = [statsText, sprintf('汽车平均等待时间: %.2f秒\n', carAvgWaitTime)];
        statsText = [statsText, sprintf('汽车平均停车次数: %.2f次\n', carAvgStopCount)];
    end
    
    if stats.bikeCount > 0
        bikeLowSpeedRatio = stats.bikeLowSpeedTime / stats.bikeTotalTime;
        bikeAvgWaitTime = stats.bikeWaitingTime / stats.bikeCount;
        bikeAvgStopCount = stats.bikeStopCount / stats.bikeCount;
        
        statsText = [statsText, sprintf('自行车低速时间占比: %.2f%%\n', bikeLowSpeedRatio * 100)];
        statsText = [statsText, sprintf('自行车平均等待时间: %.2f秒\n', bikeAvgWaitTime)];
        statsText = [statsText, sprintf('自行车平均停车次数: %.2f次\n', bikeAvgStopCount)];
    end
    
    if ~isempty(vehicles)
        statsText = [statsText, sprintf('当前车辆数: %d (汽车: %d, 自行车: %d)', ...
            numel(vehicles), ...
            sum(strcmp({vehicles.type}, 'car')), ...
            sum(strcmp({vehicles.type}, 'bike')))];
    else
        statsText = [statsText, sprintf('当前车辆数: 0 (汽车: 0, 自行车: 0)')];
    end
    
    textHandle = findobj(figHandle, 'Tag', 'statsText');
    set(textHandle, 'String', statsText);
    
    drawnow;
end

%% 函数: 显示最终统计结果
function displayFinalStatistics(stats)
    % 显示仿真结束后的统计结果
    figure('Name', '仿真统计结果', 'Position', [200, 200, 1000, 600]);
    
    % 统计数据
    subplot(2, 2, 1);
    timeSteps = 1:size(stats.roadCapacity, 2);
    avgCapacity = mean(stats.roadCapacity, 1);
    plot(timeSteps * 2, avgCapacity, 'b-', 'LineWidth', 2);
    title('道路平均承载量随时间变化');
    xlabel('时间(秒)');
    ylabel('平均承载量');
    grid on;
    
    subplot(2, 2, 2);
    varCapacity = var(stats.roadCapacity, 0, 1);
    plot(timeSteps * 2, varCapacity, 'r-', 'LineWidth', 2);
    title('道路承载量方差随时间变化');
    xlabel('时间(秒)');
    ylabel('承载量方差');
    grid on;
    
    subplot(2, 2, 3);
    
    % 计算汽车和自行车统计数据
    carStats = [];
    bikeStats = [];
    
    if stats.carCount > 0
        carLowSpeedRatio = stats.carLowSpeedTime / stats.carTotalTime * 100;
        carAvgWaitTime = stats.carWaitingTime / stats.carCount;
        carAvgStopCount = stats.carStopCount / stats.carCount;
        carStats = [carLowSpeedRatio, carAvgWaitTime, carAvgStopCount];
    else
        carStats = [0, 0, 0];
    end
    
    if stats.bikeCount > 0
        bikeLowSpeedRatio = stats.bikeLowSpeedTime / stats.bikeTotalTime * 100;
        bikeAvgWaitTime = stats.bikeWaitingTime / stats.bikeCount;
        bikeAvgStopCount = stats.bikeStopCount / stats.bikeCount;
        bikeStats = [bikeLowSpeedRatio, bikeAvgWaitTime, bikeAvgStopCount];
    else
        bikeStats = [0, 0, 0];
    end
    
    % 汽车和自行车统计数据比较
    statNames = {'低速时间占比(%)', '平均等待时间(秒)', '平均停车次数'};
    bar([carStats; bikeStats]');
    title('汽车与自行车统计对比');
    set(gca, 'XTickLabel', statNames);
    legend('汽车', '自行车');
    grid on;
    
    subplot(2, 2, 4);
    totalCars = stats.carCount;
    totalBikes = stats.bikeCount;
    pie([totalCars, totalBikes], {'汽车', '自行车'});
    title(sprintf('车辆总数比例 (总计: %d)', totalCars + totalBikes));
    
    % 显示文本统计结果
    fprintf('\n最终统计结果:\n');
    fprintf('总共生成汽车: %d辆\n', stats.carCount);
    fprintf('总共生成自行车: %d辆\n', stats.bikeCount);
    
    if stats.carCount > 0
        fprintf('汽车低速时间占比: %.2f%%\n', carStats(1));
        fprintf('汽车平均等待时间: %.2f秒\n', carStats(2));
        fprintf('汽车平均停车次数: %.2f次\n', carStats(3));
    end
    
    if stats.bikeCount > 0
        fprintf('自行车低速时间占比: %.2f%%\n', bikeStats(1));
        fprintf('自行车平均等待时间: %.2f秒\n', bikeStats(2));
        fprintf('自行车平均停车次数: %.2f次\n', bikeStats(3));
    end
end
